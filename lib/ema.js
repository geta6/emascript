// Generated by CoffeeScript 1.7.1

/*
 * ema - node.js supervisor script.
 */
var args, async, child, cluster, coerce, colors, defaults, ema, err, error, fs, helper, inspect, logger, mkdirp, path, pid, pkg, program, script, spawn, _;

require('coffee-script/register');

_ = require('lodash');

fs = require('fs');

path = require('path');

async = require('async');

mkdirp = require('mkdirp');

helper = require('./helper');

cluster = require('cluster');

if (cluster.isMaster) {
  program = require('commander');
  spawn = require('child_process').spawn;
  error = require('util').error;
  while (true) {
    if (fs.existsSync(path.resolve('package.json'))) {
      break;
    }
    if (process.cwd() === '/') {
      error("project definition file 'package.json' not found.");
      process.exit(1);
    }
    process.chdir('../');
  }
  pkg = require(path.resolve('package.json'));
  ema = require(path.join(path.dirname(path.dirname(process.mainModule.filename)), 'package.json'));
  defaults = {
    global: {
      name: 'ema',
      pid_path: '%d/tmp/ema.pid',
      access_log: '%d/tmp/log/access.log',
      error_log: '%d/tmp/log/error.log',
      clustering: 'auto',
      timeout: 2400,
      server: {}
    },
    server: {
      access_log: null,
      error_log: null,
      clustering: 'inherit',
      script: pkg.main || null,
      match_env: null,
      unmatch_env: null,
      env: {}
    }
  };
  program.usage('[-hVtqd] [-s signal] [-p dirname] [-c filename] [-g directives]').version(ema.version).option('-t, --test', 'test configuration and exit').option('-q, --quiet', 'suppress non-error messages during configuration testing').option('-d, --daemon', 'daemonize process').option('-s, --signal <signal>', 'send signal to a master process: stop, quit, reload').option('-p, --prefix <dirname>', 'set prefix path', path.resolve()).option('-c, --config <filename>', 'set JSON5 configuration file', 'Emafile').option('-g, --directives <directive>', 'set master directives out of configuration file', _.clone(defaults.global)).parse(process.argv);
  program = helper.configuration(program, defaults);
  if (program.prefix) {
    process.chdir(program.prefix);
  }
  if (program.signal) {
    try {
      pid = parseInt(fs.readFileSync(program.directives.pid_path, 'utf-8'), 10);
      switch (program.signal) {
        case 'stop':
          process.kill(pid, 'SIGTERM');
          break;
        case 'quit':
          process.kill(pid, 'SIGQUIT');
          break;
        case 'reopen':
          process.kill(pid, 'SIGUSR1');
          break;
        case 'reload':
          process.kill(pid, 'SIGHUP');
          break;
        default:
          throw new Error('signal should be stop, quit, reopen or reload');
      }
      process.exit(0);
    } catch (_error) {
      err = _error;
      error("! " + err.message);
      error("signal operation '" + program.signal + "' failed");
      process.exit(1);
    }
  }
  try {
    if (fs.existsSync(program.directives.pid_path)) {
      pid = parseInt(fs.readFileSync(program.directives.pid_path, 'utf-8'), 10);
      try {
        process.kill(pid, 'SIGCONT');
        error("! " + program.directives.name + " already booted.");
        process.exit(1);
      } catch (_error) {}
    }
  } catch (_error) {
    err = _error;
    fs.unlinkSync(program.directives.pid_path);
    error("! #" + pid + " already dead, clear pid_path");
  }
  if (program.daemon && !process.env.__daemon) {
    args = [].concat(process.argv);
    args.shift();
    script = args.shift();
    process.env.__daemon = true;
    child = spawn(process.execPath, [script].concat(args), {
      stdio: ['ignore', 'ignore', 'ignore'],
      env: process.env,
      cwd: process.cwd(),
      detached: true
    });
    child.unref();
    process.exit(0);
  }
  if (!fs.existsSync(path.dirname(program.directives.pid_path))) {
    mkdirp.sync(path.dirname(program.directives.pid_path));
  }
  fs.writeFile(program.directives.pid_path, process.pid, function(err) {
    var config, index, title, worker, workers, _ref, _results;
    if (err) {
      error(err.stack || err.message);
      process.exit(1);
    }
    process.title = "" + program.directives.name + ":master";
    workers = {};
    process.on('SIGHUP', function() {
      error('Reload all processes.');
      return async.eachSeries(_.keys(workers), function(uid, next) {
        var worker;
        worker = workers[uid];
        return setImmediate(function() {
          var timeout;
          timeout = setTimeout(function() {
            worker.kill('SIGTERM');
            return next(null);
          }, program.directives.timeout);
          return worker.disconnect(function() {
            clearTimeout(timeout);
            return next(null);
          });
        });
      }, function() {
        return error('Reload done.');
      });
    });
    process.on('SIGQUIT', function() {
      cluster.removeAllListeners('exit');
      return async.each(_.keys(workers), function(uid, next) {
        var worker;
        worker = workers[uid];
        return setImmediate(function() {
          var timeout;
          timeout = setTimeout(function() {
            worker.kill('SIGTERM');
            return next(null);
          }, program.directives.timeout);
          return worker.disconnect(function() {
            clearTimeout(timeout);
            return next(null);
          });
        });
      }, function() {
        fs.unlinkSync(program.directives.pid_path);
        return process.exit(0);
      });
    });
    cluster.on('exit', function(worker) {
      var config;
      delete workers[worker.uid];
      config = JSON.parse(worker.config);
      worker = cluster.fork(config.env);
      worker.uid = _.uniqueId();
      worker.config = JSON.stringify(config);
      return workers[worker.uid] = worker;
    });
    if (!process.env.NODE_ENV) {
      process.env.NODE_ENV = 'development';
    }
    _ref = program.directives.server;
    _results = [];
    for (title in _ref) {
      config = _ref[title];
      if (!(_.isRegExp(config.match_env)) || config.match_env.test(process.env.NODE_ENV)) {
        if (!(_.isRegExp(config.unmatch_env)) || !config.unmatch_env.test(process.env.NODE_ENV)) {
          _results.push((function() {
            var _i, _ref1, _results1;
            _results1 = [];
            for (index = _i = 1, _ref1 = config.clustering; 1 <= _ref1 ? _i <= _ref1 : _i >= _ref1; index = 1 <= _ref1 ? ++_i : --_i) {
              config.env = _.extend(_.clone(config.env), {
                EMA_NAME: program.directives.name,
                EMA_TITLE: title,
                EMA_CLUSTER: index,
                EMA_CLUSTERS: config.clustering,
                EMA_PREFIX: program.prefix,
                EMA_SCRIPT: config.script,
                EMA_STDOUT: config.access_log,
                EMA_STDERR: config.error_log
              });
              worker = cluster.fork(config.env);
              worker.uid = _.uniqueId();
              worker.config = JSON.stringify(config);
              _results1.push(workers[worker.uid] = worker);
            }
            return _results1;
          })());
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  });
} else {
  inspect = require('util').inspect;
  if (!process.env.NODE_ENV) {
    process.env.NODE_ENV = 'development';
  }
  colors = parseInt(process.env.EMA_CLUSTER, 10);
  colors = [6, 2, 3, 4, 5, 1][colors % 6];
  coerce = function(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    if ('object' !== typeof val) {
      return val;
    }
    return inspect(val);
  };
  logger = function(write, dst) {
    return function() {
      var date;
      date = function(d) {
        var da, ho, mi, mo, se;
        mo = ('00' + (1 + d.getMonth())).slice(-2);
        da = ('00' + d.getDate()).slice(-2);
        ho = ('00' + d.getHours()).slice(-2);
        mi = ('00' + d.getMinutes()).slice(-2);
        se = ('00' + d.getSeconds()).slice(-2);
        return "" + mo + "/" + da + " " + ho + ":" + mi + ":" + se;
      };
      args = (_.map(Array.prototype.slice.call(arguments), coerce)).join('');
      if (!/[\n\r]$/.test(args)) {
        args += '\n';
      }
      if (dst) {
        fs.appendFile(dst, "" + date + " " + args);
      }
      return write.call(this, "\u001b[9" + colors + "m" + (date(new Date())) + " worker:" + process.env.EMA_TITLE + "." + process.env.EMA_CLUSTER + "  \u001b[90m" + args + "\u001b[0m");
    };
  };
  process.chdir(process.env.EMA_PREFIX);
  process.title = "" + process.env.EMA_NAME + ":worker:" + process.env.EMA_TITLE + "." + process.env.EMA_CLUSTER;
  process.env.EMA_STDOUT = helper.conversion(process.env.EMA_STDOUT);
  process.env.EMA_STDERR = helper.conversion(process.env.EMA_STDERR);
  process.env.EMA_SCRIPT = helper.conversion(process.env.EMA_SCRIPT);
  if (!_.isNull(process.env.EMA_STDOUT = helper.conversion(process.env.EMA_STDOUT))) {
    mkdirp.sync(path.dirname(process.env.EMA_STDOUT));
  }
  process.stdout.write = logger(process.stdout.write, process.env.EMA_STDOUT);
  if (!_.isNull(process.env.EMA_STDERR = helper.conversion(process.env.EMA_STDERR))) {
    mkdirp.sync(path.dirname(process.env.EMA_STDERR));
  }
  process.stderr.write = logger(process.stderr.write, process.env.EMA_STDERR);
  if (require.cache[process.env.EMA_SCRIPT] != null) {
    delete require.cache[process.env.EMA_SCRIPT];
  }
  require(process.env.EMA_SCRIPT);
}
